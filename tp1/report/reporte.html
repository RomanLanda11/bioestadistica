<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Irisarri - Landa">

<title>TP1 Bioestdística</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="reporte_files/libs/clipboard/clipboard.min.js"></script>
<script src="reporte_files/libs/quarto-html/quarto.js"></script>
<script src="reporte_files/libs/quarto-html/popper.min.js"></script>
<script src="reporte_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="reporte_files/libs/quarto-html/anchor.min.js"></script>
<link href="reporte_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="reporte_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="reporte_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="reporte_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="reporte_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TP1 Bioestdística</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Irisarri - Landa </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div style="page-break-after: always;"></div>
<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>Se llevó a cabo un estudio de investigación clínica multicéntrico con el fin de implementar estándares mundiales de crecimiento fetal que faciliten la detección temprana de alteraciones en el desarrollo del feto dentro del últero, y de esta manera reducir la morbi-mortalidad perinatal asociada con el crecimiento.</p>
<p>Durante el período de reclutamiento, las mujeres admitidas en alguna de las clínicas de salud participantes cursando su primer trimestre de embarazo fueron invitadas a formar parte del estudio. Aquellas que cumplieron con los criterios de elegibilidad y dieron su consentimiento fueron seguidas según un esquema de visitas programado a las 14, 18, 24, 28, 32, 36 y 40 semanas de gestación. En cada visita, se tomaron medidas antropométricas del feto por medio de un ultrasonido.</p>
<p>La información necesaria para llevar a cabo el análisis se recolectó a lo largo de 17 formularios en papel. Particularmente, en el formulario de admisión se registraron algunas características de la mujeres al momento de ingresar en el estudio. A las mujeres que cumplieron todos los criterios les fue asignado un código identificador único (Subject Number) compuesto por su código de páis, código del médico responsable, y el orden de ingreso. Sólo se entrevistaron mujeres mayores de edad (18 años o más al momento de la entrevista).</p>
</section>
<section id="datos" class="level1">
<h1>Datos</h1>
<p>Contamos con una base de 1000 pacientes, con las siguentes variables:</p>
<ul>
<li><p>countrycode: Código del país (tipo: numérico)</p></li>
<li><p>Patientid: Identificación única del paciente (tipo: carácter)</p></li>
<li><p>interview: Fecha de la entrevista (tipo: fecha)</p></li>
<li><p>ethnicgroup: Grupo étnico (tipo: entero)</p></li>
<li><p>scr: Elegibilidad según el formulario CLIN-SCR (tipo: entero) Este campo indica si la mujer es elegible de acuerdo con los criterios establecidos en el formulario CLIN-SCR. Un valor de 1 indica elegibilidad, mientras que un valor de 0 indica no elegibilidad.</p></li>
<li><p>usscr: Elegibilidad según el formulario US-SCR (tipo: entero) Similar al anterior, este campo indica la elegibilidad de la mujer según el formulario US-SCR. Los valores son 1 para elegible y 0 para no elegible.</p></li>
<li><p>consent: Consentimiento (tipo: entero) Este campo refleja si la mujer aceptó participar y escribió el formulario de consentimiento. Un valor de 1 indica que firmó el consentimiento, mientras que un valor de 0 indica que no lo hizo.</p></li>
<li><p>subjectnumber : Número de sujeto (tipo: carácter) Este campo representa un número único para identificar al sujeto en el estudio, expresado como texto.</p></li>
</ul>
<p>Los primeros registros son:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 10
  countrycode patientid interview  ethnicgroup   scr usscr consent subjectnumber
        &lt;int&gt; &lt;chr&gt;     &lt;date&gt;           &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;        
1          14 15/03/19… 2014-02-03           3     2     2       2 014003017    
2          31 19/03/19… 2011-03-29           1     2     2       2 031001011    
3          23 26/11/19… 2014-06-25           1     2     2       2 023009024    
4          11 18/04/19… 2014-03-18           3     2     2       2 011002135    
5          11 01/01/19… 2014-02-25           3     2     2       2 011002120    
6          31 13/12/19… 2011-04-01           1     2     2       2 031002012    
# ℹ 2 more variables: fechaid &lt;date&gt;, inicialesid &lt;chr&gt;</code></pre>
</div>
</div>
</section>
<section id="reglas" class="level1">
<h1>Reglas</h1>
<p>Se realizaron diversas validaciones para asegurar la integridad y calidad de los datos de los pacientes. A continuación, se detallan las comprobaciones efectuadas:</p>
<p>1.Identificador del Paciente: Se comprobó la existencia del identificador único asignado a cada registro (no valores faltantes).</p>
<p>2.Código de País: Se comprobó la existencia del código de país para cada paciente (no valores faltantes).</p>
<p>3.Formato del Código de País: Se validó que el código de país se registrara como un número entero.</p>
<p>4.Validez del Código de País: Se comprobó que el código de país correspondiera a una lista predefinida de códigos válidos.</p>
<p>5.Fecha de Identificación: Se comprobó la existencia de la fecha de identificación para cada paciente (no valores faltantes).</p>
<p>6.Formato de la Fecha de Identificación: Se verificó que la fecha de identificación se registrara en un formato de fecha válido.</p>
<p>7.Iniciales del Paciente: Se comprobó la existencia de las iniciales del paciente en cada registro (no valores faltantes).</p>
<p>8.Formato de las Iniciales: Se validó que las iniciales del paciente se registraran como texto.</p>
<p>9.Formato Específico de las Iniciales: Se comprobó que las iniciales consistieran exactamente en dos letras mayúsculas.</p>
<p>10.Fecha de la Entrevista: Se comprobó la existencia de la fecha de la entrevista para cada paciente (no valores faltantes).</p>
<p>11.Formato de la Fecha de la Entrevista: Se validó que la fecha de la entrevista se registrara en un formato de fecha válido.</p>
<p>12.Grupo Étnico: Se comprobó la existencia de información sobre el grupo étnico del paciente (no valores faltantes).</p>
<p>13.Formato del Grupo Étnico: Se validó que el grupo étnico se registrara como un número entero.</p>
<p>14.Validez del Grupo Étnico: Se comprobó que el código del grupo étnico correspondiera a una lista predefinida de valores válidos.</p>
<p>15.Resultado del Screening (SCR): Se comprobó la existencia del resultado del screening (no valores faltantes).</p>
<p>16.Validez del Resultado del Screening (SCR): Se comprobó que el resultado del screening correspondiera a una lista predefinida de valores válidos.</p>
<p>17.Resultado del Ultra-Screening (USSCR): Se comprobó la existencia del resultado del ultra-screening (no valores faltantes).</p>
<p>18.Validez del Resultado del Ultra-Screening (USSCR): Se comprobó que el resultado del ultra-screening correspondiera a una lista predefinida de valores válidos.</p>
<p>19.Consentimiento Informado: Se comprobó la existencia de información sobre el consentimiento informado del paciente (no valores faltantes).</p>
<p>20.Validez del Consentimiento Informado: Se comprobó que la información del consentimiento informado correspondiera a una lista predefinida de valores válidos.</p>
<p>21.Número de Sujeto: Se comprobó la existencia del número de sujeto asignado a cada paciente (no valores faltantes).</p>
<p>22.Obligatoriedad del Número de Sujeto: Se validó que el número de sujeto estuviera presente en los casos donde el paciente pasó las etapas de screening y consentimiento.</p>
<p>23.Consistencia del Número de Sujeto con el Código de País: Se comprobó que los primeros tres dígitos del número de sujeto coincidieran con el código de país del paciente.</p>
<p>24.Ausencia Inesperada del Número de Sujeto (SCR=1): Se verificó que el número de sujeto no estuviera presente en los casos donde el resultado del screening fue negativo.</p>
<p>25.Ausencia Inesperada del Número de Sujeto (USSCR=1): Se verificó que el número de sujeto no estuviera presente en los casos donde el resultado del ultra-screening fue negativo.</p>
<p>26.Ausencia Inesperada del Número de Sujeto (Consent=1): Se verificó que el número de sujeto no estuviera presente en los casos donde el paciente no dio su consentimiento.</p>
<p>27.Mayoría de Edad del Paciente: Se validó que, para los casos donde se disponía de la fecha de identificación y la fecha de la entrevista, el paciente tuviera la edad legal establecida.</p>
</section>
<section id="resultados" class="level1">
<h1>Resultados</h1>
<p>Luego de aplicar las reglas de validación a nuestra base, compartimos los siguientes resultados:</p>
<ul>
<li>Matriz de validación de tipo Registro (filas) X Regla (columnas)</li>
</ul>
<p><img src="C:/Escritorio/FACULTAD/5°%20año%201°%20cuatrimestre/Bioestadística/bioestadistica/tp1/valid.png.jpeg" class="img-fluid"></p>
<ul>
<li>Número de participantes limpios:</li>
</ul>
<p>La cantidad de registros sin errores es 759, lo que equivale a un 75,9% de la base.</p>
<ul>
<li>Participantes con inconsistencias:</li>
</ul>
<p>La lista de participantes con inconsistencias es</p>
<p><img src="C:/Escritorio/FACULTAD/5°%20año%201°%20cuatrimestre/Bioestadística/bioestadistica/tp1/errores%20x%20reg.jpeg" class="img-fluid"></p>
<ul>
<li>Inconsistencias más frecuentes:</li>
</ul>
<p>Las inconsistencias mas frecuentes son:</p>
<ol type="1">
<li><p>En primer lugar, la regla 21, que indica <em>subject number</em> como dato faltante. El campo cuenta con 100 valores perdidos en nuestra base.</p></li>
<li><p>Lugo, la regla 22, que verifica que <em>subject number</em> es vacio siendo que debia estar completo.</p></li>
<li><p>Por último, la regla 14, que evalua si el campo <em>ethnic group</em> es uno de los valores admitidos.</p></li>
</ol>
<p>Presentamos el resto de las reglas con errores en las siguiente tabla:</p>
<p><img src="C:/Escritorio/FACULTAD/5°%20año%201°%20cuatrimestre/Bioestadística/bioestadistica/tp1/errores.jpeg" class="img-fluid"></p>
<ul>
<li>Campos con más errores:</li>
</ul>
<p>El campo con mas errores de la base es <em>subject number</em> con 97 errores.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>