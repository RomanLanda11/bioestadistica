---
title: "TP 3 Bioestdística"
author: "Irisarri - Landa"
toc: false
output:
  pdf_document: default
toc-title: Contenido
execute:
  warning: false
  message: false
editor_options: 
  markdown: 
    wrap: sentence
---

\thispagestyle{empty}

\begin{center}
  \vspace*{1cm}

  \Huge
  \textbf{TP 3: Estandarización de Tasas}

  \vspace{0.5cm}
  \LARGE

  \vspace{1.5cm}

  \textbf{Alumnos:}  Malena Irisarri, Román Landa\\

  \vfill

  \includegraphics[width=0.9\textwidth]{../tp2/img/logo_universidad.jpg}

  \vspace{0.8cm}


  Rosario, Argentina

  29 de Mayo de 2025
\end{center}

\newpage

# Introducción

La estandarización de tasas es una herramienta fundamental en epidemiología y demografía que permite comparar indicadores de salud entre poblaciones con estructuras demográficas diferentes. Este método ajusta las tasas crudas (por ejemplo, de mortalidad o morbilidad) para eliminar el efecto de, por ejemplo, la edad o el sexo, lo que facilita la identificación de patrones y desigualdades reales entre grupos o regiones.

En este trabajo práctico, se aplicará la estandarización de tasas para analizar las muertes por **infarto agudo de miocardio** durante el **años 2023** en las provincias de Argentina, utilizando como referencia la población estándar del país. A través de este proceso, se calcularán tasas estandarizadas por edad (RME), lo que permitirá comparar el riesgo de muerte entre provincias de manera precisa.



```{r include=FALSE}
# Función de limpieza común para los grupos de edad
clean_age_group <- function(age_string) {
  age_string <- str_replace(age_string, "^\\d{2}_", "") # Eliminar el prefijo "XX_"
  age_string <- str_trim(age_string) # Eliminar espacios
  age_string <- str_replace_all(age_string, "\\s+", " ")# Reemplazar múltiples espacios internos con un solo espacio
  # Usar un "negative lookahead" para asegurar que "a" no esté seguido de "y" (para preservar "y más")
  age_string <- str_replace(age_string, " a (?![y])", "-")
  age_string <- str_replace(age_string, "ymás", " y más")# Corregir casos como "80ymás" o "100ymás" para que tengan el espacio correcto
  return(age_string)
}

####### CARGAR LIBRERÍAS Y DATOS ###########
library(readxl)
library(readr)
library(stringr)
library(dplyr)
library(tidyr)
```

```{r include=FALSE}
######################## Tratamiento de defunciones ############################
defunciones <- read_delim("defweb23.csv",
                          delim = ";", escape_double = FALSE, trim_ws = TRUE)
causa <- 'I21' # Causa de defunción: Infarto agudo del miocardio

# Aplicar la función de limpieza a GRUPEDAD en 'defunciones' antes de agrupar
defunciones <- defunciones %>%
  mutate(GRUPEDAD = clean_age_group(GRUPEDAD))

# Filtrar por causa, agrupar por provincia y grupo de edad, y sumar 'CUENTA'
defunciones <- defunciones %>%
  filter(CAUSA == causa) %>%
  group_by(PROVRES, GRUPEDAD) %>%
  summarise(
    cuenta_total = sum(CUENTA, na.rm = TRUE)
  ) %>%
  ungroup()

# Cargar el archivo de códigos de provincia
cod_provincias <- read_excel("descdef1.xlsx",
                             sheet = "PROVRES")

# Realizar la unión (merge) de 'defunciones' con los nombres de provincia
defunciones <- defunciones %>%
  left_join(cod_provincias %>% select(CODIGO, VALOR), by = c("PROVRES" = "CODIGO"))

################################################################################


# Cargar y limpiar el dataframe 'edades'
edades <- read_excel("c2_proyecciones_prov_2010_2040.xls",
                     sheet = "01-TOTAL DEL PAÍS", range = "A59:A84")
edades <- edades[!apply(is.na(edades), 1, all), ]

# Aplicar la función de limpieza a la columna 'Edad' en 'edades'
edades <- edades %>%
  mutate(Edad = clean_age_group(Edad))


# Define la ruta de tu archivo principal (proyecciones provinciales)
ruta_archivo <- "c2_proyecciones_prov_2010_2040.xls"

# Obtener nombres de las hojas del archivo Excel y filtrar "GraphData"
nombres_hojas <- excel_sheets(ruta_archivo)
nombres_hojas <- nombres_hojas[nombres_hojas != "GraphData"]
```

# Estandarización Directa

```{r}
# Inicializar un vector para almacenar los nombres de los data frames generados
nombres_dfs_generados <- c()

# Bucle para procesar cada hoja del archivo de proyecciones
for (hoja in nombres_hojas) {
  # print(hoja) # Descomentar para depuración
  
  # 1. Leer los datos de la hoja actual
  datos_hoja <- read_excel(ruta_archivo,
                           sheet = hoja,
                           range = "F60:H84")
  
  # Eliminar filas donde TODAS las columnas son NA
  datos_hoja <- datos_hoja[!apply(is.na(datos_hoja), 1, all), ]
  
  # Verificar y unir 'edades' al data frame actual
  if (nrow(edades) != nrow(datos_hoja)) {
    warning(paste("El número de filas en 'edades' (", nrow(edades), ") no coincide con 'datos_hoja' (", nrow(datos_hoja), ") para la hoja:", hoja, ". Saltando esta hoja."))
    next # Saltar a la siguiente iteración del bucle
  }
  datos_hoja <- cbind(Edad = edades$Edad, datos_hoja) # Asegurar que la columna se llame 'Edad'
  
  # Extraer los dos primeros dígitos del nombre de la hoja para 'codigo_prov'
  codigo_provincia <- str_extract(hoja, "^\\d{2}")
  
  # Agregar la columna 'codigo_prov' al data.frame (como carácter)
  datos_hoja$codigo_prov <- codigo_provincia
  
  # Limpiar el nombre de la hoja para usarlo como nombre de variable en R
  nombre_limpio <- tolower(hoja)
  nombre_limpio <- str_replace_all(nombre_limpio, "^\\d{2}-", "") # Eliminar prefijo numérico
  nombre_limpio <- str_replace_all(nombre_limpio, "ñ", "n") # Reemplazar 'ñ'
  nombre_limpio <- str_replace_all(nombre_limpio, "[áéíóúü]", function(x) { # Quitar tildes
    chartr("áéíóúü", "aeiouu", x)
  })
  nombre_limpio <- str_replace_all(nombre_limpio, "[[:space:]]", "_") # Reemplazar espacios por guiones bajos
  nombre_limpio <- str_replace_all(nombre_limpio, "[^a-z0-9_]", "") # Eliminar caracteres no alfanuméricos
  
  # Eliminar la primera fila (asumiendo que es una fila de totales)
  datos_hoja <- datos_hoja[-1, ]
  
  # Convertir columnas numéricas a tipo numérico para cálculos
  cols_numericas <- c("Ambos sexos", "Varones", "Mujeres")
  for (col in cols_numericas) {
    if (col %in% colnames(datos_hoja)) {
      datos_hoja[[col]] <- as.numeric(datos_hoja[[col]])
    }
  }
  
  # Calcular la columna '%poblacion'
  datos_hoja$`%poblacion` <- (
    datos_hoja$`Ambos sexos` / sum(datos_hoja$`Ambos sexos`, na.rm = TRUE)
  ) * 100
  
  # Lógica para colapsar grupos de edad "80 y más"
  grupos_a_colapsar <- c("80-84", "85-89", "90-94", "95-99", "100 y más")
  nombre_columna_grupo_edad <- "Edad"
  
  filas_a_colapsar <- datos_hoja %>%
    filter(get(nombre_columna_grupo_edad) %in% grupos_a_colapsar)
  
  filas_no_colapsadas <- datos_hoja %>%
    filter(!get(nombre_columna_grupo_edad) %in% grupos_a_colapsar)
  
  if (nrow(filas_a_colapsar) > 0) {
    fila_colapsada <- filas_a_colapsar %>%
      summarise(
        !!nombre_columna_grupo_edad := "80 y más",
        `Ambos sexos` = sum(`Ambos sexos`, na.rm = TRUE),
        `Varones` = sum(`Varones`, na.rm = TRUE),
        `Mujeres` = sum(`Mujeres`, na.rm = TRUE),
        `%poblacion` = sum(`%poblacion`, na.rm = TRUE),
        codigo_prov = first(codigo_prov) # Tomar el código de provincia
      )
    datos_hoja <- bind_rows(filas_no_colapsadas, fila_colapsada)
  }
  
  # Realizar el merge con 'defunciones'
  datos_hoja <- datos_hoja %>%
    left_join(defunciones,
              by = c("codigo_prov" = "PROVRES", "Edad" = "GRUPEDAD"))
  
  # Asignar el data frame procesado al entorno global con el nombre limpio
  assign(nombre_limpio, datos_hoja, envir = .GlobalEnv)
  
  # Mensaje de confirmación y almacenamiento del nombre
  cat("Creado data frame:", nombre_limpio, "\n")
  nombres_dfs_generados <- c(nombres_dfs_generados, nombre_limpio)
}

######################### Metodo Directo Estandarizacion ###########################

tasas_totales <- list()
tasa_estandar_directo <- list()
for (nombre_df_provincia in nombres_dfs_generados) {
  provincia_df <- get(nombre_df_provincia, envir = .GlobalEnv)
  
  # Calcula la 'tasa_por_edad'
  provincia_df <- provincia_df %>%
    mutate(
      tasa_por_edad = ifelse(
        !is.na(`Ambos sexos`) & `Ambos sexos` != 0,
        cuenta_total / `Ambos sexos`,
        0 # O NA
      )
    )
  provincia_df$defunciones_estandar <- provincia_df$tasa_por_edad*total_del_pais$`Ambos sexos`
  
  # Calcula la 'tasa_total' ponderada por fila
  tasa_total_ponderada <- sum(
    (provincia_df$tasa_por_edad * (provincia_df$`%poblacion` / 100)), # %poblacion / 100 
    na.rm = TRUE # Importante para que la suma ignore los NA
  )
  tasa_estandar <- sum((provincia_df$defunciones_estandar), na.rm = TRUE )/ sum(total_del_pais$`Ambos sexos`)
  
  # Almacena la tasa total ponderada en la lista 'tasas_totales'
  tasas_totales[[nombre_df_provincia]] <- tasa_total_ponderada
  tasa_estandar_directo[[nombre_df_provincia]] <- tasa_estandar
  
  
  # Asigna el data frame actualizado con 'tasa_por_edad' de nuevo al entorno global
  assign(nombre_df_provincia, provincia_df, envir = .GlobalEnv)
}
```

# Metodo Indirecto

```{r}

# Recalcular defunciones_totales (esto está bien como lo tienes)
defunciones_totales <- defunciones %>%
  group_by(GRUPEDAD) %>%
  summarise(
    cuenta_total = sum(cuenta_total, na.rm = TRUE)
  ) %>%
  ungroup() # Es buena práctica desagrupar

# Asegúrate de que 'total_del_pais' esté disponible y su columna 'Edad' esté limpia
# Si 'total_del_pais' es el dataframe '01-total_del_pais' que generaste en el primer bucle
# simplemente llámalo así:
# total_del_pais <- get("total_del_pais", envir = .GlobalEnv) # Asegúrate de que este nombre sea correcto.

defunciones_totales <- defunciones_totales %>%
  left_join(
    total_del_pais %>% select(Edad, `Ambos sexos`),
    by = c("GRUPEDAD" = "Edad")
  ) %>%
  mutate(
    tasa = ifelse(
      !is.na(`Ambos sexos`) & `Ambos sexos` != 0,
      cuenta_total / `Ambos sexos`,
      0 # Si 'Ambos sexos' es NA o 0, la tasa es 0.
    )
  )

# --- FIN DE LA PREPARACIÓN, INICIO DEL BUCLE DE CÁLCULO DE RME ---
# Asegúrate de que defunciones_totales_con_tasa_nacional ya esté definido y contenga la columna 'tasa'
# y que nombres_dfs_generados esté lleno con los nombres de tus dataframes provinciales.

# Asumo que las librerías necesarias (dplyr, tidyr, etc.) ya están cargadas al inicio del script.

rme_indirecta <- list()

for (nombre_df_provincia in nombres_dfs_generados) {
  provincia_df <- get(nombre_df_provincia, envir = .GlobalEnv)

  # --- PASO 1: Joinear la columna 'tasa_nacional' (renombrada durante el select) ---
  provincia_df <- provincia_df %>%
    left_join(
      # Seleccionamos GRUPEDAD, y renombramos 'tasa' a 'tasa_nacional' aquí mismo
      defunciones_totales %>% select(GRUPEDAD, tasa_nacional = tasa), # <-- ¡CAMBIO AQUÍ!
      by = c("Edad" = "GRUPEDAD") # Las unimos por las columnas de grupo de edad
    ) %>%
    # Aseguramos que la nueva columna 'tasa_nacional' no tenga NAs, reemplazándolos con 0
    mutate(tasa_nacional = replace_na(tasa_nacional, 0)) # <--- ¡CAMBIO AQUÍ!
  # ----------------------------------------------------------------------------------

  # --- PASO 2: Calcular 'defunciones_indirectas' usando la nueva columna 'tasa_nacional' ---
  provincia_df <- provincia_df %>%
    mutate(
      # Ahora usamos 'tasa_nacional' para el cálculo
      defunciones_indirectas = `Ambos sexos` * tasa_nacional # <--- ¡CAMBIO AQUÍ!
    )

  # --- Calculo de RME ---
  total_esperado <- sum(provincia_df$defunciones_indirectas, na.rm = TRUE)
  total_observado <- sum(provincia_df$cuenta_total, na.rm = TRUE)
  if (total_esperado != 0) {
    rme_indirecta[[nombre_df_provincia]] <- total_observado / total_esperado
  } else {
    rme_indirecta[[nombre_df_provincia]] <- NaN
    warning(paste("Total esperado es cero para", nombre_df_provincia, ". RME será NaN/Inf."))
  }

  assign(nombre_df_provincia, provincia_df, envir = .GlobalEnv)
}

print("Razones de Mortalidad Estandarizadas Indirectas (RME):")
print(rme_indirecta)
```

# Resultados

```{r}
df_resultados <- tibble(
  provincia = nombres_dfs_generados, # Nombre de la provincia (ej. "buenos_aires")
  rme = as.numeric(rme_indirecta[nombres_dfs_generados]), # Razón de Mortalidad Estandarizada Indirecta
  tasas_provinciales = as.numeric(tasas_totales[nombres_dfs_generados]), # Tasa provincial cruda/ponderada
  tasas_estandar_directas = as.numeric(tasa_estandar_directo[nombres_dfs_generados]) # Tasa Estandarizada Directa
)
df_resultados <- df_resultados[-1,]
```


```{r}
library(ggplot2)
ggplot(df_resultados) + # Assuming your dataframe is named df_resultados_consolidados
  aes(x = provincia, y = rme) +
  geom_col(fill = "steelblue") + # Use geom_col() for pre-summarized data
  labs(
    title = "Razón de Mortalidad Estandarizada (RME) por Provincia",
    x = "Provincia",
    y = "RME"
  ) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", linewidth = 0.8) +
  theme_minimal() + # A cleaner theme
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
library(ggplot2)
library(tidyr) # Necesitas tidyr para pivot_longer()
library(dplyr) # Asegúrate de que dplyr también esté cargado

# --- 1. Pivotar el dataframe de resultados a formato largo ---
df_tasas_long <- df_resultados %>%
  select(provincia, tasas_provinciales, tasas_estandar_directas) %>% # Seleccionamos solo las columnas de interés
  pivot_longer(
    cols = c(tasas_provinciales, tasas_estandar_directas), # Las columnas que queremos pivotar
    names_to = "tipo_tasa", # Nuevo nombre para la columna que contendrá los nombres originales
    values_to = "valor_tasa" # Nuevo nombre para la columna que contendrá los valores
  ) %>%
  # Opcional: Renombrar los valores de 'tipo_tasa' para que sean más legibles en la leyenda
  mutate(
    tipo_tasa = case_when(
      tipo_tasa == "tasas_provinciales" ~ "Tasa Provincial Cruda",
      tipo_tasa == "tasas_estandar_directas" ~ "Tasa Estandarizada Directa",
      TRUE ~ tipo_tasa # Por si hay otros valores, aunque no debería
    )
  )

# --- 2. Crear el gráfico con las dos barras por provincia ---
ggplot(df_tasas_long) +
  aes(x = provincia, y = valor_tasa, fill = tipo_tasa) + # 'fill' usará 'tipo_tasa' para el color y agrupar
  geom_col(position = "dodge") + # 'position = "dodge"' coloca las barras lado a lado
  labs(
    title = "Comparación de Tasas de Mortalidad por Provincia",
    subtitle = "Tasa Provincial Cruda vs. Tasa Estandarizada Directa",
    x = "Provincia",
    y = "Valor de la Tasa",
    fill = "Tipo de Tasa" # Etiqueta para la leyenda de colores
  ) +
  geom_hline(yintercept = sum(total_del_pais$tasa_nacional*(total_del_pais$`%poblacion`/100)), linetype = "dashed", color = "red", linewidth = 0.8) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + # Rotar etiquetas del eje x
  scale_fill_brewer(palette = "Paired") # Utiliza una paleta de colores predefinida
```
```



